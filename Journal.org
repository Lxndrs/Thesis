RECORD OF THE THESIS PROGRESS

* Tasks

** DONE Portada
- [X] Contenido e la Portada
  - [X] Texto
  - [X] Logos de la UNAM y del IRyA

- [-] Formato de la Portada
  - [X] Tama\~no correcto del texto 
  - [ ] L\'ineas.
** TODO Escribir el Prefacio de la tesis
- [ ] Agradecimientos
- [ ] Abstract (en ingl\'es y en espa\~nol)

** DONE Darle el formato general a la tesis.
- [X] T\'itulos de cap\'itulos, secciones y ap\'endices en espa\~nol.
- [X] Formato de p\'agina.

** DONE Buscar ideas principales en notas de la maestría
   - [ ] Choques
   - [ ] Vientos Estelares
   - [ ] Regiones HII
   - [ ] Frentes de Ionización
*** Choques
*** Vientos Estelares
*** Frentes de Ionización
Situación: se trata de una fuente puntual
que emite de forma radial fotones ionizantes y 
que está rodeado de gas neutro.
(e.g una estrella masiva rodeada de gas inicialmente neutro)
    - N_ν (t): Tasa de fotones ionizantes.
     Normalmente N_ν = N_*
    - Propiedades del medio circundante (gas neutro):
      - ρ = μ m_H
      - v = 0
    - Gas ionizado: 
      - ρ = ρ(r,t)
      - v = v(r,t)
    - Llamamos X al grado de ionización del gas.
    - Y la distancia donde se ubica la transición entre el gas neutro y el gas ionizado 
      se denota como r_IF.
El equilibrio de ionización se alcanza cuando la tasa de fotoionizaciones es igual a la de
recombinaciones:
$$N_{stellar} = ∫₀^{r_IF}4π r²nₑnₚα_{rec} dr $$


*** Regiones HII 

** TODO Write !!!!!!
** DONE Truncar en dos líneas ecuaciones largas y otras correcciones menores
- [X] Sección 3.2.2 Reducir tamaño de font
- [X] Sección 4.2 Agregar o corregir ecuación
- [X] Apéndice A cortar ecuación muy larga
- [X] Corregir referencia en apéndice A.1
- [X] Cortar ecuaciones muy largas en apéndice B.3
** TODO Completar secciones
   - [X] Choques
   - [X] Vientos Estelares
   - [ ] Objetos LL
   - [-] Regiones HII
     - [X] Segunda Expansión
     - [X] Flujos de Champaña
     - [ ] Emisión
   - [X] Cuádricas
   - [ ] Conclusiones
** TODO Gráfica de \Pi' vs R'_0/D' con observaciones incluídas
- [X] Graficar las curvas teóricas para 4 valores de k en 4 subgráficas
- [X] Incluir las observaciones en las 4 subgráficas junto con las incertidumbres de las submuestras
- [ ] Mejorar detalles (etiquetas de los ejes, etc)
* Journal
-[2018-05-14 Mon]
- Created a Programs bar into Journal.org
- Moving python scripts into Programs bar, editing and tangling controlled here
- Almost finished \Pi' vs R'_0/D' graph with observations
-[2018-05-11 Fri]
- Finished Apparent shape for thin shell model section
- Correcting projection onto the plane of sky section inserting rotation matrix
- Insert appendix about rotation matrix (B)
- Other corrections
-[2018-02-07 Wed]
- Finished First and second expansion subsection
- Insert figure
-[2018-02-06 Thu]
- Make huge changes in thesis structure
  - Thin shell model is now a separated chapter
  - Chapter ``Marco Teórico'' dissapeared, split content into chapter 1
    now called ``Objetos y Fenómenos Astrofísicos Relevantes'' and chapter 2, now called ``Conceptos fundamentales''
- Work in HII regions section. Almost finished.
- Incorporate paper terminology into thesis. In progress.
- Finished Quadrics of revolution section.
- Make new figures and incorporate others from paper.
-[2017-11-30 Thu]
- Working in Appendix C
  - Write something about
  - Working in generating figures for Hyperbolic tail coefficents
-[2017-11-29 Wed]
- Corrections to thesis format
  - Portada
  - Headers
  - References
  - Make the file compile in Computer desktop
  - Split in two lines too long equations
  - Put the chapter titles with the rest of the content instead of being in a separated page
- [2017-11-17 Sat]
Long time I don't write anything here !!! =(
- Hard Work in chapters 1, 2, 3 and 4
   - Insert molecular clouds section: Short reference to Enrique and
     Javier Work to put into conext the formation of OB associations like
     Orion
   - Moved CRW formalism of the two winds interaction into a separated chapter
     (and virtully finished it!!)
   - Good advances in chapter 4: apply the CRW model to real bowshocks and 
     explain how to fit the shapes into quadrics for both head and tail

- Insert appendix to show elemental subjects and hard math.
 
- [2017-05-17 Tue]
  - Work in "Projection onto the plane of the sky section"
  - Insert figures
  - Small improvement in format

-[2017-05-12 Fri]
  - Work in ``Projection onto the plane of the sky section''
  - Insert figures

- [2017-05-08 Mon]
  - Work in ``generic model section''
  - Insert some figures

- [2017-02-28 Tue]
  - Update README.md
    - Reorganize sections from chapters 1 & 2
  - Search old notes to start writing

- [2017-02-03 Fri]
  - Updated README.md

- [2017-02-02 Thu]
  - Add some sections to Chapter 1
  - Think in adjunting first paper to chapter 2

- [2017-01-13 Fri] 
  - Work schedule organized: 
    - Move work folder to home.
    - Create thesis journal.
  - Start thesis Cover page.   

- [2017-01-14 Sat]
  - Install missing LaTeX packages to use babel spanish
  - Convert thesis format to spanish
  - Insert fancyhdr package and apply to document, but haven't been implemented properly yet.

-[2017-01-17 Tue]

  - Yesterday's missing entry: Convert thesis folder into a github repository
* Programs
** Jupyter notebooks
./Picture Maker.ipynb
./Picture Maker II.ipynb

** Other Scripts
*** Plot Apparent planitude vs inclination: mod-pi-vs-i.py
- Tangle with C-u C-c C-v t
#+NAME: mod-pi-vs-i
#+BEGIN_SRC python :eval no :tangle ./mod-pi-vs-i.py
import sys
sys.path.insert(0,"../bowshock-shape/Dust-wave/")
sys.path.insert(0,"../bowshock-shape/")
import numpy as np
from matplotlib import pyplot as plt
import matplotlib.ticker
import seaborn as sns
import bow_projection as bp
import ancantoid_shape
import bow_diagnostic

#####################################
# Modify program to plot            #
# \Pi' vs inclination               #
# instead of \Lambda' vs \Pi'       #
# Document everyhing as I           #
# understand what each command does #
#####################################

# Maybe I won't need this
#try: 
#    xiset = sys.argv[1] # Additional argument in command line to enter the anisotropy parameter 'xi'
#    plotfile = sys.argv[0].replace('.py', f'-{xiset}.pdf') # The output pdf file will be the name of the program itself with extension
#    assert xiset in 'ab' #Test searching potential errors  # '.pdf' instead of '.py' 
#    istart = -2 if xiset == 'a' else -1 # Honestly I don't know what this means
#except:
#    sys.exit(f"Usage: {sys.argv[0]} a|b") # Exit in case of failure

#sns.set_style('ticks') #Set plot axis style
# Adapt the style to the other graphs I have so far
sns.set_style("white") 
#fig, ax = plt.subplots(figsize=(4, 4)) # set subplot size
f = plt.figure()
ax1 = f.add_subplot(1, 3, 1, adjustable="box") # wilkinoid + cantoid plot
ax2 = f.add_subplot(1, 3, 2, adjustable="box") # Ancantoid xi=0.8 plot
ax3 = f.add_subplot(1, 3, 3, adjustable="box") # Ancantoid xi=0.4 plot

bp.N_NEIGHBORHOOD = 50
bp.DEGREE_POLY_NEIGHBORHOOD = 2
bp.SCALE_NEIGHBORHOOD = 0.03 
bp.DEGREE_POLY_NEIGHBORHOOD_90 = 2
bp.SCALE_NEIGHBORHOOD_90 = 0.01     #Stuff from bow_projection classes

#left_annotate_pars = dict(xytext=(-5, 5), ha='right', va='bottom')
#right_annotate_pars = dict(xytext=(5, -5), ha='left', va='top') # set location oftext inside plot


#Rc_grid = np.linspace(0.0, 10.0, 2000)
#R90_T0_grid = np.sqrt(2*Rc_grid)
#R90_T1_grid = np.sqrt(2*Rc_grid - 1.0)
#R90_T1_grid[~np.isfinite(R90_T1_grid)] = 0.0 #set grids for shaded regions

#ax.fill_between(Rc_grid, R90_T1_grid, R90_T0_grid, color='k', alpha=0.2)
#ax.fill_between(Rc_grid, R90_T0_grid, color='k', alpha=0.1) # shade the different regions in diagram
#ax.plot(Rc_grid, R90_T0_grid, c='k', lw=0.5) # Plot the parabolic interface
#ax.axhline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1) #plot horizontal line
#ax.axvline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1) #plot vertical line
#ax.plot([0.0, 10.0], [0.0, 10.0], lw=0.5, alpha=0.5, color='k', zorder=-1) #Plot diagonal identity line

XI_LIST = [None, 0.8, 0.4]
BETA_LIST = [0.005, 0.01, 0.05, 0.08, 0.5]
nxi, nbeta = len(XI_LIST), len(BETA_LIST) # set shells parameters (xi=None for cantoid shell)
cols = sns.color_palette('magma', n_colors=nbeta+1) # color palette of curves
# Put a cross at the Wilkinoid coordinates: [5/3, sqrt(3)]
#ax.plot([5./3.], [np.sqrt(3.0)], '+', c='w', ms=10, alpha=1.0)
# And plot the projected wilkinoids 
shape = bp.wilkinoid_R_theta
th_inf = bp.theta_infinity(shape)
inc = np.linspace(0.0, th_inf - np.pi/2, 50)
tab = bow_diagnostic.parameter_table(inc, shape)
Rc, R90 = tab['tilde R_c prime'], tab['tilde R_90 prime']
ax1.plot(np.degrees(inc), Rc, '-', c=cols[0], label="wilkinoid", lw=2.0, alpha=1.0)
#sini = np.linspace(0.0, 1.0, 20)
#inc_e = np.arcsin(sini)
#tab_e = bow_diagnostic.parameter_table(inc_e, shape)
#Rc_e, R90_e = tab_e['tilde R_c prime'], tab_e['tilde R_90 prime']
#ax.scatter(Rc_e, R90_e, marker='|', s=3**2,
#           linewidths=0.1, edgecolors='none',
#           c='w', alpha=0.5, label="_nolabel_")

#annot_pars_list = [right_annotate_pars]*2 + [left_annotate_pars]*2 
#for beta in BETA_LIST[::-1]:
#    for xi, col, annot_pars in list(zip(XI_LIST, cols, annot_pars_list))[istart::-2]: #start loops in beta and xi
for xi in XI_LIST:
    k = None if xi is None else 2/xi - 2
    for beta, col in zip(BETA_LIST, cols[1:]):    
#        if beta == BETA_LIST[0]:
#            label = "Cantoid" if k is None else fr"Ancantoid $k = {k:.1f}$" # set label into plot
#        else:
#            label = "_nolabel_"
#
        if xi is None: #cantoid case
            shape = bp.Spline_R_theta_from_function(
                ngrid=1000,
                shape_func=bp.cantoid_R_theta,
                shape_func_pars=(beta,))
        else: #ancantoid case
            shape = ancantoid_shape.Ancantoid(xi=xi, beta=beta, n=301)

        th_inf = bp.theta_infinity(shape)
        inc = np.linspace(0.0, th_inf - np.pi/2, 200)
        tab = bow_diagnostic.parameter_table(inc, shape)
        Rc, R90 = tab['tilde R_c prime'], tab['tilde R_90 prime']
        label = r"$\beta={}$".format(beta)
        if xi is None:
            ax1.plot(np.degrees(inc), Rc, '-', c=col, label=label, lw=1.0, alpha=1.0) #Plot Rc vs i
        elif xi==0.8:
            ax2.plot(np.degrees(inc), Rc, '-', c=col, label=label, lw=1.0, alpha=1.0) #Plot Rc vs i
        else:
            ax3.plot(np.degrees(inc), Rc, '-', c=col, label=label, lw=1.0, alpha=1.0) #Plot Rc vs i
        # Get points evenly spaced in sin i
#        sini = np.linspace(0.0, 1.0, 20)
#        inc_e = np.arcsin(sini)
#        inc_e = inc_e[inc_e < th_inf - np.pi/2]
#        tab_e = bow_diagnostic.parameter_table(inc_e, shape)
#        Rc_e, R90_e = tab_e['tilde R_c prime'], tab_e['tilde R_90 prime']
#        ax.scatter(Rc_e, R90_e, marker='|', s=3**2,
#                   linewidths=0.1, edgecolors='none',
#                   c=col, alpha=0.5, label="_nolabel_")

        # Put a dot at the i=0 case
#        ax.plot(Rc[0:1], R90[0:1], 'o', mec='none', c=col, label="_nolabel_", alpha=0.7)
        # Label the dot with the cross-over inclination
#        beta_label = rf'$\beta = \mathrm{{{beta:g}}}$'
#        if beta_label.endswith('1}$'):
            # But only for some of them
#            ax.annotate(beta_label, xy=(Rc[0], R90[0]),
#                        textcoords='offset points',
#                        fontsize='x-small', color=col, **annot_pars)


ax3.legend(ncol=1, fontsize='small', frameon=True, title=r"Ancantoid $k=3.0$") # legends board
ax3.set(
    yscale='linear',
    xscale='linear',
    xlim=[0.0, 90.0],
    ylim=[0.8, 6.0],
#    ylim=[-3.0, 1.1],
#    xlabel=r"inclination (deg)",
#    ylabel=r"Projected planitude: $\Pi'$", #Plot settings
)        

ax1.legend(ncol=1, fontsize='small', frameon=True, title="Isotropic inner wind") # legends board
ax1.set(
    yscale='linear',
    xscale='linear',
    xlim=[0.0, 90.0],
    ylim=[0.8, 6.0],
#    ylim=[-3.0, 1.1],
    xlabel=r"inclination (deg)",
    ylabel=r"Projected planitude: $\Pi'$", #Plot settings
)

ax2.legend(ncol=1, fontsize='small', frameon=True, title=r"Ancantoid $k=0.5$") # legends board
ax2.set(
    yscale='linear',
    xscale='linear',
    xlim=[0.0, 90.0],
    ylim=[0.8, 6.0],
#    ylim=[-3.0, 1.1],
#    xlabel=r"inclination (deg)",
#    ylabel=r"Projected planitude: $\Pi'$", #Plot settings
)
#sns.despine()
ax1.text(5, 5.8, "( a )")
ax2.text(5, 5.8, "( b )")
ax3.text(5, 5.8, "( c )")
f.tight_layout()
f.set_size_inches(17, 10)
f.savefig("./Figures/Pi-vs-i.pdf")
#print(plotfile, end='')
# The End
#+END_SRC
*** Plot \Pi' vs R'_0/D' for new thin shell models vs observations

- Tangle with C-u C-c C-v t

#+NAME: obs-diagramrm
#+BEGIN_SRC python :eval no :tangle ./obs-diagram.py
  import numpy as np
  import matplotlib.pyplot as plt
  import matplotlib.ticker
  import seaborn as sns
  import sys
  sys.path.insert(0,"../bowshock-shape/Dust-wave/")
  sys.path.insert(0,"../bowshock-shape/")
  import json
  import glob
  import bow_projection as bp
  import ancantoid_shape
  import bow_diagnostic

  # Set graph style
  f = plt.figure()


  sns.set_style("ticks")

  # Set theoretical curves

  bp.N_NEIGHBORHOOD = 50
  bp.DEGREE_POLY_NEIGHBORHOOD = 2
  bp.SCALE_NEIGHBORHOOD = 0.03 
  bp.DEGREE_POLY_NEIGHBORHOOD_90 = 2
  bp.SCALE_NEIGHBORHOOD_90 = 0.01     #Stuff from bow_projection classes

  XI_LIST = [None, 0.8, 0.4, 0.2]
  BETA_LIST = [5e-4, 0.001, 0.002, 0.005, 0.01, 0.02, 0.05, 0.1]
  nxi, nbeta = len(XI_LIST), len(BETA_LIST) # set shells parameters (xi=None for cantoid shell)
  cols = sns.color_palette('magma', n_colors=nbeta) # color palette of curves

  #collection of hex colors
  dark_blue = "#1e25b6"
  pearl_turquoise ="#32c6a6"
  mexican_pink = "#e4007c"
  crimson = "#dc143c"
  leaf_green = "#15ae26"
  brown = "#b6451e"
  gray = "#515952"
  guinda = "#aa1c47"
  gold = "#FFD700"
  orange = "#E08000"
  #Create a dictionary with hex colors for the objects
  colordict = {"LV2":dark_blue, "LV2b":pearl_turquoise, "LV3":mexican_pink, "LV4":crimson, "LV5":brown, "168-328":leaf_green, "169-338":gray, "177-341":guinda, "180-331":orange}

  m_savefiles = glob.glob("./saves/LV-bowshocks-xyfancy-positionswill-*.save")
  dict_xtext = {"LV2":10, "LV2b":-10, "LV3":10, "LV4":10, "LV5":10, "168-328":-10, "169-338":-10, "177-341":10, "180-331":-20}
  dict_ytext = {"LV2":10, "LV2b":10, "LV3":-10, "LV4":10, "LV5":10, "168-328":10, "169-338":10, "177-341":-10, "180-331":-20}

  for n, xi in enumerate(XI_LIST):
      k = None if xi is None else 2/xi - 2
      ax = f.add_subplot(2, 2, n+1, adjustable="box") 
      for beta, col in zip(BETA_LIST, cols):    
  #        if beta == BETA_LIST[0]:
  #            label = "Cantoid" if k is None else fr"Ancantoid $k = {k:.1f}$" # set label into plot
  #        else:
  #            label = "_nolabel_"
  #
          if xi is None: #cantoid case
              shape = bp.Spline_R_theta_from_function(
                  ngrid=1000,
                  shape_func=bp.cantoid_R_theta,
                  shape_func_pars=(beta,))
          else: #ancantoid case
              shape = ancantoid_shape.Ancantoid(xi=xi, beta=beta, n=301)

          th_inf = bp.theta_infinity(shape)
          inc = np.linspace(0.0, th_inf - np.pi/2, 200)
          tab = bow_diagnostic.parameter_table(inc, shape)
          Rc, R0pR0 = tab['tilde R_c prime'], tab['R_0 prime']
          R0D = np.sqrt(beta)/(1+np.sqrt(beta))
          DDp = 1./np.cos(inc)
          R0 = R0pR0*R0D*DDp
          label = r"$\beta={}$".format(beta)
          ax.plot(R0, Rc, '-', c=col, label=label, lw=1.0, alpha=1.0)
          # Get points evenly spaced in sin i
          sini = np.linspace(0.0, 1.0, 20)
          inc_e = np.arcsin(sini)
          inc_e = inc_e[inc_e < th_inf - np.pi/2]
          tab_e = bow_diagnostic.parameter_table(inc_e, shape)
          Rc_e, R0pR0_e = tab_e['tilde R_c prime'], tab_e['R_0 prime']
          DDp_e = 1./np.cos(inc_e)
          R0_e = R0pR0_e*R0D*DDp_e
          ax.scatter(R0_e, Rc_e, marker='|', s=3**2,
                     linewidths=0.1, edgecolors='none',
                     c=col, alpha=0.5, label="_nolabel_")

          # Put a dot at the i=0 case
          ax.plot(R0[0:1], Rc[0:1], 'o', mec='none', c=col, label="_nolabel_", alpha=0.7)



      #Add the observational points
      for savefile in m_savefiles:
          data = json.load(open(savefile))
          combined_file = savefile.replace('positionswill', 'variations')
          vardata = json.load(open(combined_file))
          ax.plot(data["R0"], data["Rc"]/data["R0"],
                 # color=colordict[data["proplyd"]],
                 color='k',
                 marker="o")
          ax.annotate(data["proplyd"], xy=(data["R0"], data["Rc"]/data["R0"]),
                     xytext=(dict_xtext[data["proplyd"]], dict_ytext[data["proplyd"]]),
                     textcoords="offset points", fontsize="xx-small",
                     bbox=dict(boxstyle='round, pad=0.5',
                               fc=colordict[data["proplyd"]],
                               alpha=0.5))
          # Plot the variations of the fits with points removed
          R0_d = data["R0"]
          A = data["Rc"]/data["R0"]
          var_R0 = vardata["R0"]
          var_A = np.array(vardata["Rc"])/np.array(vardata["R0"])
          for vR0, vA in zip(var_R0, var_A):
  #        # Scale gives fractional deviation from typical value
              scale = np.hypot((vR0 - R0_d)/0.25, (vA - A)/1.5)
              alpha = 1./(1 + 20.0*scale)
              ax.plot([R0_d, vR0], [A, vA], '-',
                      lw=2, alpha=alpha, color=colordict[data["proplyd"]])
          ktitle = "Cantoid" if k is None else r"$k={}$".format(k) 
          ax.legend(loc="upper right", title=ktitle, fontsize="x-small", ncol=2)
  f.set_size_inches(8, 8)
  f.tight_layout()
  f.savefig("test2.pdf")

#+END_SRC
